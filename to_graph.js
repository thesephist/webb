#!/usr/bin/env node
/* This thing takes the main Webb algorithm's matrix output
 * and turns it into vector graphics. */

var fs = require('fs'),
    result,
    resultArray,
    node_coords = [],
    links = [],
    pop_size;

// Taking matrix input file, parse variables

// for now, for testing
var result = "Matrix[[0.859589583861773, 0.774754878574261, 0.9271405415910646, 0.774754878574261, 0.9271405415910646, 0.31062758869791546, 0.31062758869791546, 0.31062758869791546, 0.46683490716508635, 0.31062758869791546, 0.6700765952157539, 0.8385594858453704, 0.8385594858453704, 0.6700765952157539, 0.6700765952157539], [0.7747548785742605, 0.6982926889108754, 0.8356390901046186, 0.6982926889108754, 0.8356390901046186, 0.27997109816324683, 0.27997109816324683, 0.27997109816324683, 0.4207619875871754, 0.27997109816324683, 0.6039453256629004, 0.7558002851950524, 0.7558002851950524, 0.6039453256629004, 0.6039453256629004], [0.9271405415910644, 0.8356390901046189, 1.0, 0.8356390901046189, 1.0, 0.33503829760787696, 0.33503829760787696, 0.33503829760787696, 0.5035211882374934, 0.33503829760787696, 0.722734650418626, 0.9044577906239754, 0.9044577906239754, 0.722734650418626, 0.722734650418626], [0.7747548785742605, 0.6982926889108754, 0.8356390901046186, 0.6982926889108754, 0.8356390901046186, 0.27997109816324683, 0.27997109816324683, 0.27997109816324683, 0.4207619875871754, 0.27997109816324683, 0.6039453256629004, 0.7558002851950524, 0.7558002851950524, 0.6039453256629004, 0.6039453256629004], [0.9271405415910644, 0.8356390901046189, 1.0, 0.8356390901046189, 1.0, 0.33503829760787696, 0.33503829760787696, 0.33503829760787696, 0.5035211882374934, 0.33503829760787696, 0.722734650418626, 0.9044577906239754, 0.9044577906239754, 0.722734650418626, 0.722734650418626], [0.3106275886979151, 0.2799710981632466, 0.3350382976078766, 0.2799710981632466, 0.3350382976078766, 0.11225066086398428, 0.11225066086398428, 0.11225066086398428, 0.16869888171658504, 0.11225066086398428, 0.2421437868984804, 0.3030279984288381, 0.3030279984288381, 0.2421437868984804, 0.2421437868984804], [0.3106275886979151, 0.2799710981632466, 0.3350382976078766, 0.2799710981632466, 0.3350382976078766, 0.11225066086398428, 0.11225066086398428, 0.11225066086398428, 0.16869888171658504, 0.11225066086398428, 0.2421437868984804, 0.3030279984288381, 0.3030279984288381, 0.2421437868984804, 0.2421437868984804], [0.3106275886979151, 0.2799710981632466, 0.3350382976078766, 0.2799710981632466, 0.3350382976078766, 0.11225066086398428, 0.11225066086398428, 0.11225066086398428, 0.16869888171658504, 0.11225066086398428, 0.2421437868984804, 0.3030279984288381, 0.3030279984288381, 0.2421437868984804, 0.2421437868984804], [0.46683490716508635, 0.4207619875871756, 0.5035211882374934, 0.4207619875871756, 0.5035211882374934, 0.16869888171658518, 0.16869888171658518, 0.16869888171658518, 0.25353358700409734, 0.16869888171658518, 0.36391220995919615, 0.4554136614456423, 0.4554136614456423, 0.36391220995919615, 0.36391220995919615], [0.3106275886979151, 0.2799710981632466, 0.3350382976078766, 0.2799710981632466, 0.3350382976078766, 0.11225066086398428, 0.11225066086398428, 0.11225066086398428, 0.16869888171658504, 0.11225066086398428, 0.2421437868984804, 0.3030279984288381, 0.3030279984288381, 0.2421437868984804, 0.2421437868984804], [0.6700765952157532, 0.6039453256629002, 0.7227346504186257, 0.6039453256629002, 0.7227346504186257, 0.24214378689848048, 0.24214378689848048, 0.24214378689848048, 0.363912209959196, 0.24214378689848048, 0.5223453749157334, 0.6536829851250214, 0.6536829851250214, 0.5223453749157334, 0.5223453749157334], [0.8385594858453699, 0.7558002851950522, 0.9044577906239749, 0.7558002851950522, 0.9044577906239749, 0.30302799842883815, 0.30302799842883815, 0.30302799842883815, 0.45541366144564194, 0.30302799842883815, 0.6536829851250213, 0.8180438950204026, 0.8180438950204026, 0.6536829851250213, 0.6536829851250213], [0.8385594858453699, 0.7558002851950522, 0.9044577906239749, 0.7558002851950522, 0.9044577906239749, 0.30302799842883815, 0.30302799842883815, 0.30302799842883815, 0.45541366144564194, 0.30302799842883815, 0.6536829851250213, 0.8180438950204026, 0.8180438950204026, 0.6536829851250213, 0.6536829851250213], [0.6700765952157532, 0.6039453256629002, 0.7227346504186257, 0.6039453256629002, 0.7227346504186257, 0.24214378689848048, 0.24214378689848048, 0.24214378689848048, 0.363912209959196, 0.24214378689848048, 0.5223453749157334, 0.6536829851250214, 0.6536829851250214, 0.5223453749157334, 0.5223453749157334], [0.6700765952157532, 0.6039453256629002, 0.7227346504186257, 0.6039453256629002, 0.7227346504186257, 0.24214378689848048, 0.24214378689848048, 0.24214378689848048, 0.363912209959196, 0.24214378689848048, 0.5223453749157334, 0.6536829851250214, 0.6536829851250214, 0.5223453749157334, 0.5223453749157334]]";

result = result.substring(8,result.length - 2); // so in the form "1.0, 1.0, 1.0], [1.0, 1.0, 1.0" and so on

var resultArray = result.split("], ["); // so each element in the form 1.0, 1.0, 1.0 and so on
resultArray.forEach(function(string){
    links.push(string.split(", "));
});

// count number of nodes in population
pop_size = resultArray.length;

// have node coordinates put in array of duples
var angle = Math.PI / pop_size * 2;
for(i=0;i<pop_size;i++){
    node_coords.push([500 - 500 * Math.sin(angle * i).toString(), 500 - 500 * Math.cos(angle * i).toString()]);
}

// have segment startNode, endNode, strength in array, will resolve node coordinates from node list
var maximum=0.0;
var minimum=1.0;
var linkc = links;
for(i=0; i<pop_size; i++){
    for(j=0; j<pop_size; j++){
        links[i][j] = parseFloat(links[i][j]);
    }
}
for(i=0; i<pop_size; i++){
    for(j=0; j<pop_size; j++){
        links[i][j] = Math.sqrt(linkc[i][j] * linkc[j][i]);
    }
}
for(i=0; i<pop_size; i++){
    for(j=0; j<pop_size; j++){
        if(i!=j){
            if(links[i][j]>maximum){maximum = links[i][j]}
            if(links[i][j]<minimum){minimum = links[i][j]}
    
        }
    }
}

console.log(maximum + " - " + minimum);
console.log(linkc);

// will write SVG line by line
SVGlines = ["<svg xmlns='http://www.w3.org/2000/svg' version='1.0' viewBox='0 0 1000 1000'>"];

// write lines first
var writtenlines = ""
SVGlines.push("<!-- connections -->");
for(i=0;i<pop_size;i++){
    for(j=0;j<pop_size;j++){
        writtenlines+="0x"+node_coords[i]+"x0"+node_coords[j];
        if(writtenlines.indexOf("0x"+node_coords[j]+"x0"+node_coords[i])==-1){
            SVGlines.push("<line x1='" + node_coords[i][0] + "' y1='" + node_coords[i][1] + "' x2='" + node_coords[j][0] + "' y2='" + node_coords[j][1] + "' style='stroke:#000;stroke-width:6;opacity:" + (((links[i][j] - minimum) / (maximum - minimum)) + 0.0).toString() + "'/>");
        }
    }
}

// write nodes later
SVGlines.push("<!-- nodes -->");
node_coords.forEach(function(coord){
    SVGlines.push("<circle cy='" + coord[1] + "' cx='" + coord[0] + "' r='10' style='fill:#5200A3'/>");
});

// below is all good, writing to files everything front-back
fs.writeFile("graph.svg", "", function(err) {
    if(err) {return console.log(err);}
});

SVGlines.forEach(function(line){
    // this is the end
    fs.appendFile("graph.svg", line, function(err) {
        if(err) {
            return console.log(err);
        }
        
    });
});

fs.appendFile("graph.svg", "</svg>", function(err) {
    if(err) {return console.log(err);}
});
          
console.log("Graph Saved!");
