#!/usr/bin/env node
/* This thing takes the main Webb algorithm's matrix output
 * and turns it into vector graphics. */

var fs = require('fs'),
    result,
    resultArray,
    node_coords = [],
    links = [],
    pop_size;

// Taking matrix input file, parse variables

// for now, for testing
var result = "Matrix[[0.31200835569137075, 0.40191870624586795, 0.4001518224634282, 0.38251123194513403, 0.27107588886422657, 0.357077242080271, 0.42450460618353575, 0.392962028938942, 0.46805667916678956, 0.357077242080271, 0.4720022277945243, 0.41136008468771185, 0.5258165392819005, 0.41136008468771185, 0.48312965840505356], [0.49208836389304234, 0.6338917389614699, 0.6311050728220398, 0.6032829670696648, 0.42753115169931216, 0.5631693986844278, 0.6695134152448832, 0.6197655962600612, 0.7382021790782897, 0.5631693986844278, 0.7444249585713977, 0.648782348932298, 0.8292989562483226, 0.648782348932298, 0.761974744083564], [0.45194224730590166, 0.5821768567251636, 0.579617536446646, 0.5540652450684546, 0.39265181591459297, 0.5172242654799716, 0.6148924024816486, 0.569203165921726, 0.6779773212521834, 0.5172242654799716, 0.6836924275837031, 0.595852643224656, 0.7616421403051095, 0.595852643224656, 0.6998104441081654], [0.4288456710833502, 0.5524246204334072, 0.5499960943389371, 0.525749658071178, 0.3725852858821325, 0.4907914437890841, 0.5834682355386538, 0.5401139546642252, 0.6433291922444363, 0.4907914437890841, 0.6487522202952, 0.5654015010746939, 0.722718298882349, 0.5654015010746939, 0.6640465228249754], [0.3120083530722664, 0.401918706245868, 0.4001518224634283, 0.3825112319451342, 0.27107589148333106, 0.35707724208027103, 0.4245046061835359, 0.39296202893894217, 0.4680566791667897, 0.35707724208027103, 0.47200222779452444, 0.41136008468771196, 0.5258165392819008, 0.41136008468771196, 0.483129658405054], [0.3810342258960299, 0.4908355182905847, 0.48867774570713685, 0.46713451476064066, 0.33104623464067434, 0.43607377500625844, 0.518418154438694, 0.4798973833200851, 0.5716052884555485, 0.43607377500625844, 0.5764236976391777, 0.5023656368956483, 0.6421433929549621, 0.5023656368956483, 0.5900128535233017], [0.45700864629950155, 0.5887032210601861, 0.5861152100499561, 0.5602764730381892, 0.3970535490185128, 0.5230225285337838, 0.6217855557936127, 0.575584126893005, 0.6855776729050638, 0.5230225285337838, 0.6913568327982629, 0.6025323322865224, 0.7701803771540022, 0.6025323322865224, 0.7076555290049642], [0.40889148591415575, 0.5267203051492557, 0.524404778654503, 0.5012865306187979, 0.35524889140496785, 0.46795495029122064, 0.5563194938804517, 0.5149824849410969, 0.6133951178629891, 0.46795495029122064, 0.6185658002037182, 0.5390933848998684, 0.6890902360495176, 0.5390933848998684, 0.6331484541996212], [0.5058713592368532, 0.6516465300277582, 0.6487818128357988, 0.6201804368812358, 0.43950594887341254, 0.5789433473893228, 0.6882659757867338, 0.637124756897864, 0.7588786561291847, 0.5789433473893228, 0.7652757131793565, 0.6669542269310514, 0.8525269630050464, 0.6669542269310514, 0.7833170459481339], [0.3810342258960299, 0.4908355182905847, 0.48867774570713685, 0.46713451476064066, 0.33104623464067434, 0.43607377500625844, 0.518418154438694, 0.4798973833200851, 0.5716052884555485, 0.43607377500625844, 0.5764236976391777, 0.5023656368956483, 0.6421433929549621, 0.5023656368956483, 0.5900128535233017], [0.5318329755693358, 0.6850894195661782, 0.6820776824380189, 0.6520084596636151, 0.4620616548106274, 0.6086550455405061, 0.7235881806995912, 0.6698223597715072, 0.7978247419673345, 0.6086550455405061, 0.8045501333818378, 0.7011827320269197, 0.8962791677497286, 0.7011827320269197, 0.8235173604889209], [0.4665475032181511, 0.6009908621914242, 0.598348832557031, 0.5719707744125073, 0.40534100257290306, 0.533939231951131, 0.6347636801878505, 0.5875979163034621, 0.6998872902988429, 0.533939231951131, 0.7057871061220089, 0.6151086320318686, 0.7862558889228315, 0.6151086320318686, 0.7224260007365304], [0.593378711826686, 0.7643705743968319, 0.7610103102231959, 0.7274613604032653, 0.5155331886360458, 0.6790909205571948, 0.8073245522780076, 0.7473367491713182, 0.8901520554942693, 0.6790909205571948, 0.897655731546954, 0.7823262620435761, 1.0, 0.7823262620435761, 0.9188179192718221], [0.4665475032181511, 0.6009908621914242, 0.598348832557031, 0.5719707744125073, 0.40534100257290306, 0.533939231951131, 0.6347636801878505, 0.5875979163034621, 0.6998872902988429, 0.533939231951131, 0.7057871061220089, 0.6151086320318686, 0.7862558889228315, 0.6151086320318686, 0.7224260007365304], [0.5544184372131019, 0.7141832573426903, 0.711043617207287, 0.6796974382991952, 0.4816841237850152, 0.6345029206924537, 0.7543169422367246, 0.6982678402383796, 0.8317061255168324, 0.6345029206924537, 0.8387171268225779, 0.7309600017108754, 0.93434163773035, 0.7309600017108754, 0.8584898408027264]]";

result = result.substring(8,result.length - 2); // so in the form "1.0, 1.0, 1.0], [1.0, 1.0, 1.0" and so on

var resultArray = result.split("], ["); // so each element in the form 1.0, 1.0, 1.0 and so on
resultArray.forEach(function(string){
    links.push(string.split(", "));
});

// count number of nodes in population
pop_size = resultArray.length;

// have node coordinates put in array of duples
var angle = Math.PI / pop_size * 2;
for(i=0;i<pop_size;i++){
    node_coords.push([500 - 500 * Math.sin(angle * i).toString(), 500 - 500 * Math.cos(angle * i).toString()]);
}

// have segment startNode, endNode, strength in array, will resolve node coordinates from node list
var maximum=0.0;
var minimum=1.0;
var linkc = links;
for(i=0; i<pop_size; i++){
    for(j=0; j<pop_size; j++){
        links[i][j] = parseFloat(links[i][j]);
    }
}
for(i=0; i<pop_size; i++){
    for(j=0; j<pop_size; j++){
        links[i][j] = Math.sqrt(linkc[i][j] * linkc[j][i]);
    }
}
for(i=0; i<pop_size; i++){
    for(j=0; j<pop_size; j++){
        if(i!=j){
            if(links[i][j]>maximum){maximum = links[i][j]}
            if(links[i][j]<minimum){minimum = links[i][j]}
    
        }
    }
}

var node_sizes = [];
for (i=0; i<pop_size; i++) {
    sum = 0;
    for (j=0; j<pop_size; j++) {
        sum += links[i][j];
    }
    node_sizes.push(sum);
}

var maxsize = Math.max.apply(null, node_sizes),
    minsize = Math.min.apply(null, node_sizes);

// will write SVG line by line
SVGlines = ["<svg xmlns='http://www.w3.org/2000/svg' version='1.0' viewBox='0 0 1000 1000'>"];

// write lines first
var writtenlines = ""
SVGlines.push("<!-- connections -->");
for(i=0;i<pop_size;i++){
    for(j=0;j<pop_size;j++){
        writtenlines+="0x"+node_coords[i]+"x0"+node_coords[j];
        if(writtenlines.indexOf("0x"+node_coords[j]+"x0"+node_coords[i])==-1){
            SVGlines.push("<line x1='" + node_coords[i][0] + "' y1='" + node_coords[i][1] + "' x2='" + node_coords[j][0] + "' y2='" + node_coords[j][1] + "' style='stroke:#000;stroke-width:2;opacity:" + (((links[i][j] - minimum) / (maximum - minimum))).toString() + "'/>");
        }
    }
}

// write nodes later
SVGlines.push("<!-- nodes -->");
node_coords.forEach(function(coord){
    SVGlines.push("<circle cy='" + coord[1] + "' cx='" + coord[0] + "' r='" + (((node_sizes[node_coords.indexOf(coord)] - minsize) / (maxsize - minsize)) * 16 + 4).toString() + "' style='fill:#B80000'/>");
});

// below is all good, writing to files everything front-back
fs.writeFile("graph.svg", "", function(err) {
    if(err) {return console.log(err);}
});

SVGlines.forEach(function(line){
    // this is the end
    fs.appendFile("graph.svg", line, function(err) {
        if(err) {
            return console.log(err);
        }
        
    });
});

fs.appendFile("graph.svg", "</svg>", function(err) {
    if(err) {return console.log(err);}
});
          
console.log("Graph Saved!");
